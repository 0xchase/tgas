use std::net::Ipv6Addr;
use plugin::contracts::{Predicate, PluginInfo};
use crate::analysis::predicates::reserved::{
    LoopbackPredicate, UnspecifiedPredicate, LinkLocalPredicate, UniqueLocalPredicate
};

pub struct Eui64Analysis;
pub struct IsPrivacyExtensionPredicate;
pub struct IsLowByteHostPredicate;

impl Eui64Analysis {
    fn is_eui64_format(&self, addr: Ipv6Addr) -> bool {
        let bytes = addr.octets();
        let interface_id = &bytes[8..16];
        interface_id[3] == 0xff && interface_id[4] == 0xfe
    }
}

impl PluginInfo for Eui64Analysis {
    const NAME: &'static str = "eui64_analysis";
    const DESCRIPTION: &'static str = "Analyzes IPv6 addresses for EUI-64 format and provides statistics";
}

impl Predicate for Eui64Analysis {
    type In = Ipv6Addr;

    fn predicate(&self, addr: Self::In) -> bool {
        self.is_eui64_format(addr)
    }
}

impl PluginInfo for IsPrivacyExtensionPredicate {
    const NAME: &'static str = "is_privacy_extension_predicate";
    const DESCRIPTION: &'static str = "Checks if the address is likely a temporary one generated by Privacy Extensions (i.e., not EUI-64 and not a well-known type).";
}

impl Predicate for IsPrivacyExtensionPredicate {
    type In = Ipv6Addr;

    fn predicate(&self, addr: Self::In) -> bool {
        // Use the special predicates to check if it's a globally addressable address
        let loopback_pred = LoopbackPredicate;
        let unspecified_pred = UnspecifiedPredicate;
        let link_local_pred = LinkLocalPredicate;
        let unique_local_pred = UniqueLocalPredicate;
        
        let is_global = !loopback_pred.predicate(addr) && 
                       !unspecified_pred.predicate(addr) && 
                       !link_local_pred.predicate(addr) && 
                       !unique_local_pred.predicate(addr);
        
        let is_eui64 = addr.octets()[8] == 0xff && addr.octets()[9] == 0xfe;

        is_global && !is_eui64
    }
}

impl PluginInfo for IsLowByteHostPredicate {
    const NAME: &'static str = "is_low_byte_host_predicate";
    const DESCRIPTION: &'static str = "Checks if the host portion of the address is a low number (e.g., ::1, ::2, ::fe), suggesting it might be a server or router.";
}

impl Predicate for IsLowByteHostPredicate {
    type In = Ipv6Addr;

    fn predicate(&self, addr: Self::In) -> bool {
        let segments = addr.segments();
        // Check if the last 64 bits (the interface ID) are less than 65536 (0xffff)
        // This indicates the first 48 bits of the interface ID are zero.
        // This pattern suggests manually configured addresses rather than auto-generated ones.
        segments[4] == 0 && segments[5] == 0 && segments[6] == 0 && segments[7] < 0xffff
    }
}
